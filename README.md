| Algoritmo                                                    | Greedy | Order Mutation | Order Crossover | Inversion Mutation | Inver Over |Greedy Population| Best results (Km)    |
|--------------------------------------------------------------|:------:|:--------------:|:---------------:|:------------------:|:----------:|:-:|--------------|
| KKN                                                          |   X    |                |                 |                    |            |    | 4379.34 Km   |
| TourGene Algorithm                                            |        |               |               |         X           |     X       |    | 4259.49 Km   |
| GreedGenesis Algorithm                        |        |                |                 |         X          |     X      |  X  | 4292.13 Km   |
| RingPath Genetic Algorithm  |        |                |               |         X          |                                              X |   | 4193.69 Km   |



## KKN (Knock Knock Neighbor)
The `KKN` function is a Nearest Neighbor-based heuristic for solving the Travelling Salesman Problem (TSP). Given a starting city, the algorithm iteratively selects the nearest unvisited city, forming an initial path by connecting cities with the shortest distances. 

Once the initial route is complete (returning to the start), a local optimization using the 2-opt technique is applied to reduce the overall path cost by swapping edges to eliminate overlapping routes. The function returns the optimized path and its total cost.

- **Parameters**: 
  - `start_city`: The name of the city to start from.
  
- **Returns**:
  - `path`: List of indices representing the ordered route through cities.
  - `cost`: Total distance of the optimized route.

## TourGene Algorithm
The `genetic_algorithm` function is a modern, steady-state genetic algorithm designed to solve the Travelling Salesman Problem (TSP). The algorithm starts with an initial population of possible routes and iteratively evolves this population to minimize the total travel cost.

1. **Modern Crossover and Mutation**: Each generation, crossover is consistently applied between pairs of selected "parent" routes using the `inver_over_crossover` method. The resulting offspring are then subjected to `inversion_mutation` with a certain probability, introducing variation to avoid local optima.

2. **Steady-State Evolution**: This approach is steady-state, meaning offspring are added directly to the existing population each generation. After offspring are created, the population is sorted based on route fitness, and only the top-performing individuals are retained to match the original population size.

3. **Progress Monitoring**: Every 100 generations, the algorithm outputs the current best route's cost for tracking improvements.

4. **Final Output**: Upon reaching the maximum number of generations, the algorithm outputs the most optimized route found and its total cost.

- **Parameters**:
  - `population`: Initial population of routes (generated with `initialize_population`).
  - `max_generations`: Maximum number of generations to run.
  - `offspring_size`: Number of offspring produced per generation.

- **Returns**:
  - `best_individual`: The most optimized route found.



## GreedGenesis Algorithm
The `genetic_algorithm` function is a steady-state genetic algorithm for solving the Travelling Salesman Problem (TSP). It iteratively refines an initial population to find a minimal-cost path through all cities. This implementation begins with a hybrid initial population, combining both greedy and randomized paths.

1. **Hybrid Initial Population**: The initial population is generated using the `initialize_population_with_greedy_and_shuffle` function, which combines diversity and heuristic optimization:
   - *Greedy Paths*: Five paths are generated using a Nearest Neighbor heuristic (`KKN` function), adding some optimized routes to the population.
   - *Random Paths*: The remaining routes are generated by random shuffling, including the start city at the beginning and end of each route for a valid TSP path.
   - *Shuffling*: The population is shuffled to introduce additional randomness and variety.

2. **Modern Crossover and Mutation**: In each generation, crossover is applied consistently between selected "parent" routes using `inver_over_crossover`, while `inversion_mutation` is applied probabilistically to introduce controlled variability.

3. **Steady-State Evolution**: This algorithm is steady-state, meaning offspring are directly added to the existing population. After creating offspring, the population is sorted by fitness, and only the top-performing routes are retained to maintain the original population size.

4. **Progress Monitoring**: Every 100 generations, the current best route cost is printed to monitor improvement.

5. **Final Output**: At the end of the specified generations, the function outputs the best path found and its total cost.

- **Parameters**:
  - `population2`: Initial population created with `initialize_population_with_greedy_and_shuffle`.
  - `max_generations`: Maximum number of generations.
  - `offspring_size`: Number of offspring per generation.

- **Returns**:
  - `best_individual`: The most optimized route found.




## RingPath genetic Algorithm
The `genetic_algorithm_circular` function is a genetic algorithm tailored for the Travelling Salesman Problem (TSP). This version utilizes a circular buffer (`deque`) for its population management, enabling efficient selection and insertion operations. It also features updated crossover and mutation functions optimized for this circular structure.

1. **Circular Buffer Population**: The population is stored in a `deque`, which acts as a circular buffer, allowing efficient addition and removal of offspring. The population is initialized with diverse routes and evolves over a fixed number of generations.

2. **Modern Crossover and Probabilistic Mutation**:
   - **Inver-Over Crossover**: `inver_over_crossover_circular` is an updated crossover function designed for circular paths, ensuring a flexible exchange of subsequences between two parent routes.
   - **Inversion Mutation**: `inversion_mutation_circular` introduces mutation by reversing a random subsequence of cities, applied with a defined probability (`MUTATION_RATE`), to maintain genetic diversity.

3. **Steady-State Evolution**: This algorithm adopts a steady-state model, where each generation’s offspring are evaluated and added directly to the population. The circular buffer is then trimmed by sorting individuals by fitness and keeping only the top-performing individuals to maintain the population’s original size.

4. **Parent Selection and Fitness Evaluation**:
   - **Parent Selection**: Parents are selected using a tournament selection strategy (`parent_selection_circular`), where the fittest individual from a random subset is chosen.
   - **Fitness Evaluation**: After generating offspring, fitness scores are recalculated using `fitness_circular`, and the population is sorted to retain the best routes.

5. **Progress Monitoring**: Every 100 generations, the algorithm outputs the best route cost, providing insights into optimization progress.

6. **Final Output**: Once the maximum number of generations is reached, the algorithm returns the best-found path and its cost.

- **Parameters**:
  - `population`: Initial population stored in a `deque`, created with `initialize_population_with_greedy_and_shuffle`.
  - `max_generations`: The maximum number of generations to evolve the population.
  - `offspring_size`: Number of offspring generated per generation.

- **Returns**:
  - `best_individual`: The most optimized route found.